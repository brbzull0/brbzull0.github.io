

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MemArena &#8212; Apache Traffic Server 10.0.0 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/override.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="AcidPtr &amp; AcidCommitPtr" href="AcidPtr.en.html" />
    <link rel="prev" title="IntrusiveHashMap" href="intrusive-hash-map.en.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="memarena">
<span id="id1"></span><h1>MemArena<a class="headerlink" href="#memarena" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="#_CPPv48MemArena" title="MemArena"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemArena</span></code></a> provides a memory arena or pool for allocating memory. Internally <a class="reference internal" href="#_CPPv48MemArena" title="MemArena"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemArena</span></code></a> reserves
memory in large blocks and allocates pieces of those blocks when memory is requested. Upon
destruction all of the reserved memory is released which also destroys all of the allocated memory.
This is useful when the goal is any (or all) of trying to</p>
<ul class="simple">
<li><p>amortize allocation costs for many small allocations.</p></li>
<li><p>create better memory locality for containers.</p></li>
<li><p>de-allocate memory in bulk.</p></li>
</ul>
<div class="section" id="description">
<h2>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>When a <a class="reference internal" href="#_CPPv48MemArena" title="MemArena"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemArena</span></code></a> instance is constructed no memory is reserved. A hint can be provided so that the
first internal reservation of memory will have close to but at least that amount of free space
available to be allocated.</p>
<p>In normal use memory is allocated from <a class="reference internal" href="#_CPPv48MemArena" title="MemArena"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemArena</span></code></a> using <a class="reference internal" href="#_CPPv4N8MemArena5allocE6size_t" title="MemArena::alloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">MemArena::alloc()</span></code></a> to get chunks
of memory, or <a class="reference internal" href="#_CPPv4I0DpEN8MemArena4makeEP1TDpRR4Args" title="MemArena::make"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">MemArena::make()</span></code></a> to get constructed class instances. <a class="reference internal" href="#_CPPv4I0DpEN8MemArena4makeEP1TDpRR4Args" title="MemArena::make"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">MemArena::make()</span></code></a>
takes an arbitrary set of arguments which it attempts to pass to a constructor for the type
<code class="code docutils literal notranslate"><span class="pre">T</span></code> after allocating memory (<code class="code docutils literal notranslate"><span class="pre">sizeof(T)</span></code> bytes) for the object. If there isn’t enough
free reserved memory, a new internal block is reserved. The size of the new reserved memory will be at least
the size of the currently reserved memory, making each reservation larger than the last.</p>
<p>The arena can be <strong>frozen</strong> using <a class="reference internal" href="#_CPPv4N8MemArena6freezeE6size_t" title="MemArena::freeze"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">MemArena::freeze()</span></code></a> which locks down the currently reserved
memory and forces the internal reservation of memory for the next allocation. By default this
internal reservation will be the size of the frozen allocated memory. If this isn’t the best value a
hint can be provided to the <a class="reference internal" href="#_CPPv4N8MemArena6freezeE6size_t" title="MemArena::freeze"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">MemArena::freeze()</span></code></a> method to specify a different value, in the
same manner as the hint to the constructor. When the arena is thawed (unfrozen) using
<a class="reference internal" href="#_CPPv4N8MemArena4thawEv" title="MemArena::thaw"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">MemArena::thaw()</span></code></a> the frozen memory is released, which also destroys the frozen allocated
memory. Doing this can be useful after a series of allocations, which can result in the allocated
memory being in different internal blocks, along with possibly no longer in use memory. The result
is to coalesce (or garbage collect) all of the in use memory in the arena into a single bulk
internal reserved block. This improves memory efficiency and memory locality. This coalescence is
done by</p>
<ol class="arabic simple">
<li><p>Freezing the arena.</p></li>
<li><p>Copying all objects back in to the arena.</p></li>
<li><p>Thawing the arena.</p></li>
</ol>
<p>Because the default reservation hint is large enough for all of the previously allocated memory, all
of the copied objects will be put in the same new internal block. If this for some reason this
sizing isn’t correct a hint can be passed to <a class="reference internal" href="#_CPPv4N8MemArena6freezeE6size_t" title="MemArena::freeze"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">MemArena::freeze()</span></code></a> to specify a different value
(if, for instance, there is a lot of unused memory of known size). Generally this is most useful for
data that is initialized on process start and not changed after process startup. After the process
start initialization, the data can be coalesced for better performance after all modifications have
been done. Alternatively, a container that allocates and de-allocates same sized objects (such as a
<code class="code docutils literal notranslate"><span class="pre">std::map</span></code>) can use a free list to re-use objects before going to the <a class="reference internal" href="#_CPPv48MemArena" title="MemArena"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemArena</span></code></a> for more
memory and thereby avoiding collecting unused memory in the arena.</p>
<p>Other than a freeze / thaw cycle, there is no mechanism to release memory except for the destruction
of the <a class="reference internal" href="#_CPPv48MemArena" title="MemArena"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemArena</span></code></a>. In such use cases either wasted memory must be small enough or temporary enough
to not be an issue, or there must be a provision for some sort of garbage collection.</p>
<p>Generally <a class="reference internal" href="#_CPPv48MemArena" title="MemArena"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemArena</span></code></a> is not as useful for classes that allocate their own internal memory
(such as <code class="code docutils literal notranslate"><span class="pre">std::string</span></code> or <code class="code docutils literal notranslate"><span class="pre">std::vector</span></code>), which includes most container classes. One
container class that can be easily used is <a class="reference internal" href="intrusive-list.en.html#_CPPv4I0E14IntrusiveDList" title="IntrusiveDList"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">IntrusiveDList</span></code></a> because the links are in the
instance and therefore also in the arena.</p>
<p>Objects created in the arena must not have <code class="code docutils literal notranslate"><span class="pre">delete</span></code> called on them as this will corrupt
memory, usually leading to an immediate crash. The memory for the instance will be released when the
arena is destroyed. The destructor can be called if needed but in general if a destructor is needed
it is probably not a class that should be constructed in the arena. Looking at
<a class="reference internal" href="intrusive-list.en.html#_CPPv4I0E14IntrusiveDList" title="IntrusiveDList"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">IntrusiveDList</span></code></a> again for an example, if this is used to link objects in the arena, there is
no need for a destructor to clean up the links - all of the objects will be de-allocated when the
arena is destroyed. Whether this kind of situation can be arranged with reasonable effort is a good
heuristic on whether <a class="reference internal" href="#_CPPv48MemArena" title="MemArena"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemArena</span></code></a> is an appropriate choice.</p>
<p>While <a class="reference internal" href="#_CPPv48MemArena" title="MemArena"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemArena</span></code></a> will normally allocate memory in successive chunks from an internal block, if the
allocation request is large (more than a memory page) and there is not enough space in the current
internal block, a block just for that allocation will be created. This is useful if the purpose of
<a class="reference internal" href="#_CPPv48MemArena" title="MemArena"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemArena</span></code></a> is to track blocks of memory more than reduce the number of system level allocations.</p>
</div>
<div class="section" id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h2>
<dl class="cpp class">
<dt id="_CPPv48MemArena">
<span id="_CPPv38MemArena"></span><span id="_CPPv28MemArena"></span><span id="MemArena"></span><em class="property">class </em><code class="sig-name descname">MemArena</code><a class="headerlink" href="#_CPPv48MemArena" title="Permalink to this definition">¶</a><br /></dt>
<dd><dl class="cpp function">
<dt id="_CPPv4N8MemArena8MemArenaE6size_t">
<span id="_CPPv3N8MemArena8MemArenaE6size_t"></span><span id="_CPPv2N8MemArena8MemArenaE6size_t"></span><span id="MemArena::MemArena__s"></span><code class="sig-name descname">MemArena</code><span class="sig-paren">(</span><a class="reference internal" href="../api/types/SystemTypes.en.html#_CPPv46size_t" title="size_t">size_t</a> <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N8MemArena8MemArenaE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a memory arena. <em>n</em> is optional. Initially not memory is reserved. If <em>n</em>
is provided this is a hint that the first internal memory reservation should provide roughly
and at least <em>n</em> bytes of free space. Otherwise the internal default hint is used. A call
to <code class="code docutils literal notranslate"><span class="pre">alloc(0)</span></code> will not allocate memory but will force the reservation of internal memory
if this should be done immediately rather than lazily.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N8MemArena5allocE6size_t">
<span id="_CPPv3N8MemArena5allocE6size_t"></span><span id="_CPPv2N8MemArena5allocE6size_t"></span><span id="MemArena::alloc__s"></span><a class="reference internal" href="MemSpan.en.html#_CPPv47MemSpan" title="MemSpan">MemSpan</a> <code class="sig-name descname">alloc</code><span class="sig-paren">(</span><a class="reference internal" href="../api/types/SystemTypes.en.html#_CPPv46size_t" title="size_t">size_t</a> <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N8MemArena5allocE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate memory of size <em>n</em> bytes in the arena. If <em>n</em> is zero then internal memory
will be reserved if there is currently none, otherwise it is a no-op.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I0DpEN8MemArena4makeEP1TDpRR4Args">
<span id="_CPPv3I0DpEN8MemArena4makeEDpRR4Args"></span><span id="_CPPv2I0DpEN8MemArena4makeEDpRR4Args"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">Args</code>&gt;<br /><a class="reference internal" href="#_CPPv4I0DpEN8MemArena4makeEP1TDpRR4Args" title="MemArena::make::T">T</a> *<code class="sig-name descname">make</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0DpEN8MemArena4makeEP1TDpRR4Args" title="MemArena::make::Args">Args</a>&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN8MemArena4makeEP1TDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an instance of <em>T</em>. <code class="code docutils literal notranslate"><span class="pre">sizeof(T)</span></code> bytes of memory are allocated from the arena
and the constructor invoked. This method takes any set of arguments, which are passed to
the constructor. A pointer to the newly constructed instance of <em>T</em> is returned. Note if
the instance allocates other memory that memory will not be in the arena. Example constructing
a <code class="code docutils literal notranslate"><span class="pre">std::string_view</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="o">*</span> <span class="n">sv</span> <span class="o">=</span> <span class="n">arena</span><span class="p">.</span><span class="n">make</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N8MemArena6freezeE6size_t">
<span id="_CPPv3N8MemArena6freezeE6size_t"></span><span id="_CPPv2N8MemArena6freezeE6size_t"></span><span id="MemArena::freeze__s"></span><a class="reference internal" href="#_CPPv48MemArena" title="MemArena">MemArena</a> &amp;<code class="sig-name descname">freeze</code><span class="sig-paren">(</span><a class="reference internal" href="../api/types/SystemTypes.en.html#_CPPv46size_t" title="size_t">size_t</a> <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N8MemArena6freezeE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stop allocating from existing internal memory blocks. These blocks are now “frozen”. Further
allocation calls will cause new memory to be reserved.</p>
<p><em>n</em> is optional. If not provided, make the hint for the next internal memory reservation
to be large enough to hold all currently (now frozen) memory allocation. If <em>n</em> is
provided it is used as the reservation hint.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N8MemArena4thawEv">
<span id="_CPPv3N8MemArena4thawEv"></span><span id="_CPPv2N8MemArena4thawEv"></span><span id="MemArena::thaw"></span><a class="reference internal" href="#_CPPv48MemArena" title="MemArena">MemArena</a> &amp;<code class="sig-name descname">thaw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N8MemArena4thawEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release all frozen internal memory blocks, destroying all frozen allocations.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N8MemArena5clearE6size_t">
<span id="_CPPv3N8MemArena5clearE6size_t"></span><span id="_CPPv2N8MemArena5clearE6size_t"></span><span id="MemArena::clear__s"></span><a class="reference internal" href="#_CPPv48MemArena" title="MemArena">MemArena</a> &amp;<code class="sig-name descname">clear</code><span class="sig-paren">(</span><a class="reference internal" href="../api/types/SystemTypes.en.html#_CPPv46size_t" title="size_t">size_t</a> <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N8MemArena5clearE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release all memory, destroying all allocations. The next memory reservation will be the size
of the allocated memory (frozen and not) at the time of the call to <a class="reference internal" href="#_CPPv4N8MemArena5clearE6size_t" title="MemArena::clear"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">MemArena::clear()</span></code></a>.
<em>n</em> is optional. If this is provided it is used as the hint for the next reserved block,
otherwise the hint is the size of all allocated memory.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="internals">
<h2>Internals<a class="headerlink" href="#internals" title="Permalink to this headline">¶</a></h2>
<p>Allocated memory is tracked by two linked lists, one for current memory and the other for frozen
memory. The latter is used only while the arena is frozen. Because a shared pointer is used for the
link, the list can be de-allocated by clearing the head pointer in <a class="reference internal" href="#_CPPv48MemArena" title="MemArena"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemArena</span></code></a>. This pattern is
similar to that used by the <code class="code docutils literal notranslate"><span class="pre">IOBuffer</span></code> data blocks, and so those were considered for use as
the internal memory allocation blocks. However, that would have required some non-trivial tweaks and,
with the move away from internal allocation pools to memory support from libraries like “jemalloc”,
unlikely to provide any benefit.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/trans_logo_tm_380x69.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">Apache Traffic Server</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../preface/index.en.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting-started/index.en.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release-notes/index.en.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.en.html">Administrator’s Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.en.html">Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../introduction/index.en.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../release-process/index.en.html">Release Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributing/index.en.html">Contributing to Traffic Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing-with-vagrant/index.en.html">Using Vagrant to Test Traffic Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../debugging/index.en.html">Debugging and Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../threads-and-events.en.html">Threads and Event Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cache-architecture/index.en.html">Cache Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../logging-architecture/index.en.html">Logging Architecture</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.en.html">Internal libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plugins/index.en.html">Plugin Development</a></li>
<li class="toctree-l2"><a class="reference internal" href="../config-vars.en.html">Configuration Variable Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/index.en.html">API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../continuous-integration/index.en.html">Continuous Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/index.en.html">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../host-resolution-proposal.en.html">Host Resolution Proposal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../client-session-architecture.en.html">An Overview Client Sessions and Transactions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../core-architecture/index.en.html">Core Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../design-documents/index.en.html">Design Documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../layout/index.en.html">Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/index.en.html">Testing Traffic Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../jsonrpc/index.en.html">JSONRPC</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../appendices/index.en.html">Appendices</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.en.html">Developer’s Guide</a><ul>
  <li><a href="index.en.html">Internal libraries</a><ul>
      <li>Previous: <a href="intrusive-hash-map.en.html" title="previous chapter">IntrusiveHashMap</a></li>
      <li>Next: <a href="AcidPtr.en.html" title="next chapter">AcidPtr &amp; AcidCommitPtr</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Apache Traffic Server</span>
    v: 10.0
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl id="lang-list">
      <dt>Languages</dt>
    </dl>
    <dl id="version-list">
      <dt>Versions</dt>
    </dl>
  </div>
</div>
<script>
$(function() {
  function update_langlist (json) {
    for (var lang in json) {
      $('#lang-list').append('<dd><a href="/' + lang + '/latest/">' + json[lang]['name'] + '</a></dd>');
    }
    for (var i in json[curlang]['versions']) {
      var ver = json[curlang]['versions'][i];
      $('#version-list').append('<dd><a href="/' + curlang + '/' + ver + '/">' + ver + '</a></dd>');
    }
  }
  var curlang = "None" == "None" ? "en" : "None";
  $.ajax({
    'url':      "/en/latest/_static/languages.json",
    'dataType': "json",
    'success':  function (json) { update_langlist(json) },
    'error':    function (xhr,errstr,e) {
      $.ajax({
        'url':      "/_static/languages.json",
        'dataType': "json",
        'success':  function (json) { update_langlist(json) }
      })
    }
  });
});
</script>

    <div class="footer">
      &copy;2021, dev@trafficserver.apache.org.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.4.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/developer-guide/internal-libraries/MemArena.en.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    

  </body>
</html>