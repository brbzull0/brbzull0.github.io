


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Header Heap &mdash; Apache Traffic Server 10.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/override.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="RPC" href="rpc.en.html" />
    <link rel="prev" title="Core Architecture" href="index.en.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Apache Traffic Server
          

          
            
            <img src="../../_static/trans_logo_tm_380x69.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                10.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../preface/index.en.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting-started/index.en.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release-notes/index.en.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.en.html">Administrator’s Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.en.html">Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../introduction/index.en.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../release-process/index.en.html">Release Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributing/index.en.html">Contributing to Traffic Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing-with-vagrant/index.en.html">Using Vagrant to Test Traffic Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../debugging/index.en.html">Debugging and Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../threads-and-events.en.html">Threads and Event Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cache-architecture/index.en.html">Cache Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../logging-architecture/index.en.html">Logging Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal-libraries/index.en.html">Internal libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plugins/index.en.html">Plugin Development</a></li>
<li class="toctree-l2"><a class="reference internal" href="../config-vars.en.html">Configuration Variable Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/index.en.html">API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../continuous-integration/index.en.html">Continuous Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/index.en.html">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../host-resolution-proposal.en.html">Host Resolution Proposal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../client-session-architecture.en.html">An Overview Client Sessions and Transactions</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.en.html">Core Architecture</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Header Heap</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rpc.en.html">RPC</a></li>
<li class="toctree-l3"><a class="reference internal" href="url_rewrite_architecture.en.html">URL Rewrite Architecture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../design-documents/index.en.html">Design Documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../layout/index.en.html">Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/index.en.html">Testing Traffic Server</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../appendices/index.en.html">Appendices</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Apache Traffic Server</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.en.html">Developer’s Guide</a> &raquo;</li>
        
          <li><a href="index.en.html">Core Architecture</a> &raquo;</li>
        
      <li>Header Heap</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/developer-guide/core-architecture/heap.en.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="header-heap">
<span id="core-hdr-heap"></span><h1>Header Heap<a class="headerlink" href="#header-heap" title="Permalink to this headline">¶</a></h1>
<p>Memory for HTTP header data is kept in <a class="reference internal" href="../../appendices/glossary.en.html#term-header-heap"><span class="xref std std-term">header heap</span></a>s.</p>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<dl class="cpp class">
<dt id="_CPPv414HdrHeapObjImpl">
<span id="_CPPv314HdrHeapObjImpl"></span><span id="_CPPv214HdrHeapObjImpl"></span><span id="HdrHeapObjImpl"></span><em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HdrHeapObjImpl</span></code><a class="headerlink" href="#_CPPv414HdrHeapObjImpl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is the abstract base class for objects allocated in a <a class="reference internal" href="#_CPPv47HdrHeap" title="HdrHeap"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrHeap</span></code></a>. This allows updating
objects in a heap in a generic way, without having to locate all of the pointers to the objects.</p>
<p>The type of an instance stored in a heap must be one of the following values.</p>
<dl class="cpp enumerator">
<dt id="_CPPv4N14HdrHeapObjImpl18HDR_HEAP_OBJ_EMPTYE">
<span id="_CPPv3N14HdrHeapObjImpl18HDR_HEAP_OBJ_EMPTYE"></span><span id="_CPPv2N14HdrHeapObjImpl18HDR_HEAP_OBJ_EMPTYE"></span><em class="property"><span class="pre">enumerator</span> </em><code class="sig-name descname"><span class="pre">HDR_HEAP_OBJ_EMPTY</span></code> <span class="pre">=</span> <span class="pre">0</span><a class="headerlink" href="#_CPPv4N14HdrHeapObjImpl18HDR_HEAP_OBJ_EMPTYE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Used to mark invalid objects, ones not yet constructed or ones that have been destroyed.</p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N14HdrHeapObjImpl16HDR_HEAP_OBJ_RAWE">
<span id="_CPPv3N14HdrHeapObjImpl16HDR_HEAP_OBJ_RAWE"></span><span id="_CPPv2N14HdrHeapObjImpl16HDR_HEAP_OBJ_RAWE"></span><em class="property"><span class="pre">enumerator</span> </em><code class="sig-name descname"><span class="pre">HDR_HEAP_OBJ_RAW</span></code> <span class="pre">=</span> <span class="pre">1</span><a class="headerlink" href="#_CPPv4N14HdrHeapObjImpl16HDR_HEAP_OBJ_RAWE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Some sort of raw object, I have no idea.</p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N14HdrHeapObjImpl16HDR_HEAP_OBJ_URLE">
<span id="_CPPv3N14HdrHeapObjImpl16HDR_HEAP_OBJ_URLE"></span><span id="_CPPv2N14HdrHeapObjImpl16HDR_HEAP_OBJ_URLE"></span><em class="property"><span class="pre">enumerator</span> </em><code class="sig-name descname"><span class="pre">HDR_HEAP_OBJ_URL</span></code> <span class="pre">=</span> <span class="pre">2</span><a class="headerlink" href="#_CPPv4N14HdrHeapObjImpl16HDR_HEAP_OBJ_URLE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A URL object.</p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N14HdrHeapObjImpl24HDR_HEAP_OBJ_HTTP_HEADERE">
<span id="_CPPv3N14HdrHeapObjImpl24HDR_HEAP_OBJ_HTTP_HEADERE"></span><span id="_CPPv2N14HdrHeapObjImpl24HDR_HEAP_OBJ_HTTP_HEADERE"></span><em class="property"><span class="pre">enumerator</span> </em><code class="sig-name descname"><span class="pre">HDR_HEAP_OBJ_HTTP_HEADER</span></code> <span class="pre">=</span> <span class="pre">3</span><a class="headerlink" href="#_CPPv4N14HdrHeapObjImpl24HDR_HEAP_OBJ_HTTP_HEADERE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The header for an HTTP request or response.</p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N14HdrHeapObjImpl24HDR_HEAP_OBJ_MIME_HEADERE">
<span id="_CPPv3N14HdrHeapObjImpl24HDR_HEAP_OBJ_MIME_HEADERE"></span><span id="_CPPv2N14HdrHeapObjImpl24HDR_HEAP_OBJ_MIME_HEADERE"></span><em class="property"><span class="pre">enumerator</span> </em><code class="sig-name descname"><span class="pre">HDR_HEAP_OBJ_MIME_HEADER</span></code> <span class="pre">=</span> <span class="pre">4</span><a class="headerlink" href="#_CPPv4N14HdrHeapObjImpl24HDR_HEAP_OBJ_MIME_HEADERE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A MIME header, containing MIME style fields with names and values.</p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N14HdrHeapObjImpl24HDR_HEAP_OBJ_FIELD_BLOCKE">
<span id="_CPPv3N14HdrHeapObjImpl24HDR_HEAP_OBJ_FIELD_BLOCKE"></span><span id="_CPPv2N14HdrHeapObjImpl24HDR_HEAP_OBJ_FIELD_BLOCKE"></span><em class="property"><span class="pre">enumerator</span> </em><code class="sig-name descname"><span class="pre">HDR_HEAP_OBJ_FIELD_BLOCK</span></code> <span class="pre">=</span> <span class="pre">5</span><a class="headerlink" href="#_CPPv4N14HdrHeapObjImpl24HDR_HEAP_OBJ_FIELD_BLOCKE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Who the heck knows?</p>
</dd></dl>

</dd></dl>

<dl class="cpp class">
<dt id="_CPPv410HdrStrHeap">
<span id="_CPPv310HdrStrHeap"></span><span id="_CPPv210HdrStrHeap"></span><span id="HdrStrHeap"></span><em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HdrStrHeap</span></code><a class="headerlink" href="#_CPPv410HdrStrHeap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a <a class="reference internal" href="../../appendices/glossary.en.html#term-variable-sized-class"><span class="xref std std-term">variable sized class</span></a>, therefore new instance must be created by <a class="reference internal" href="#_CPPv414new_HdrStrHeapi" title="new_HdrStrHeap"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">new_HdrStrHeap()</span></code></a>
and deallocated by the <code class="code docutils literal notranslate"><span class="pre">destroy</span></code> method.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv414new_HdrStrHeapi">
<span id="_CPPv314new_HdrStrHeapi"></span><span id="_CPPv214new_HdrStrHeapi"></span><span id="new_HdrStrHeap__i"></span><a class="reference internal" href="#_CPPv410HdrStrHeap" title="HdrStrHeap"><span class="pre">HdrStrHeap</span></a> <span class="pre">*</span><code class="sig-name descname"><span class="pre">new_HdrStrHeap</span></code><span class="sig-paren">(</span><span class="pre">int</span> <em><span class="pre">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414new_HdrStrHeapi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create and return a new instance of <a class="reference internal" href="#_CPPv410HdrStrHeap" title="HdrStrHeap"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrStrHeap</span></code></a>. If <em>n</em> is less than <code class="docutils literal notranslate"><span class="pre">HDR_STR_HEAP_DEFAULT_SIZE</span></code>
it is increased to that value.</p>
<p>If the allocated size is <code class="docutils literal notranslate"><span class="pre">HDR_STR_HEAP_DEFAULT_SIZE</span></code> (or smaller and upsized to that value) then
the instance is allocated from a thread local pool via <code class="code docutils literal notranslate"><span class="pre">strHeapAllocator</span></code>. If larger it
is allocated from global memory via <code class="code docutils literal notranslate"><span class="pre">ats_malloc</span></code>.</p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv47HdrHeap">
<span id="_CPPv37HdrHeap"></span><span id="_CPPv27HdrHeap"></span><span id="HdrHeap"></span><em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HdrHeap</span></code><a class="headerlink" href="#_CPPv47HdrHeap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a <a class="reference internal" href="../../appendices/glossary.en.html#term-variable-sized-class"><span class="xref std std-term">variable sized class</span></a> and therefore new instances must be created by <a class="reference internal" href="#_CPPv411new_HdrHeapi" title="new_HdrHeap"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">new_HdrHeap()</span></code></a>
and deallocated by the <code class="code docutils literal notranslate"><span class="pre">destroy</span></code> method.</p>
<p><a class="reference internal" href="#_CPPv47HdrHeap" title="HdrHeap"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrHeap</span></code></a> manages memory for heap objects directly and memory for strings via ancillary
heaps (which are instances of <a class="reference internal" href="#_CPPv410HdrStrHeap" title="HdrStrHeap"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrStrHeap</span></code></a>). For the string heaps there is at most one
writeable heap, and up to <code class="code docutils literal notranslate"><span class="pre">HDR_BUF_RONLY_HEAPS</span></code> read only heaps.</p>
<p>All objects in the internal heap must be subclasses of <a class="reference internal" href="#_CPPv414HdrHeapObjImpl" title="HdrHeapObjImpl"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrHeapObjImpl</span></code></a>.</p>
<dl class="cpp function">
<dt id="_CPPv4N7HdrHeap29required_space_for_evacuationEv">
<span id="_CPPv3N7HdrHeap29required_space_for_evacuationEv"></span><span id="_CPPv2N7HdrHeap29required_space_for_evacuationEv"></span><span id="HdrHeap::required_space_for_evacuation"></span><a class="reference internal" href="../api/types/SystemTypes.en.html#_CPPv46size_t" title="size_t"><span class="pre">size_t</span></a> <code class="sig-name descname"><span class="pre">required_space_for_evacuation</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7HdrHeap29required_space_for_evacuationEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate and return the total live string space for <em>this</em>.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N7HdrHeap23evacuate_from_str_heapsEP10HdrStrHeap">
<span id="_CPPv3N7HdrHeap23evacuate_from_str_heapsEP10HdrStrHeap"></span><span id="_CPPv2N7HdrHeap23evacuate_from_str_heapsEP10HdrStrHeap"></span><span id="HdrHeap::evacuate_from_str_heaps__HdrStrHeapP"></span><span class="pre">void</span> <code class="sig-name descname"><span class="pre">evacuate_from_str_heaps</span></code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410HdrStrHeap" title="HdrStrHeap"><span class="pre">HdrStrHeap</span></a> <span class="pre">*</span><em><span class="pre">new_heap</span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7HdrHeap23evacuate_from_str_heapsEP10HdrStrHeap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy all live strings from the heap objects in <em>this</em> to <em>new_heap</em>.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N7HdrHeap18coalesce_str_heapsEi">
<span id="_CPPv3N7HdrHeap18coalesce_str_heapsEi"></span><span id="_CPPv2N7HdrHeap18coalesce_str_heapsEi"></span><span id="HdrHeap::coalesce_str_heaps__i"></span><span class="pre">void</span> <code class="sig-name descname"><span class="pre">coalesce_str_heaps</span></code><span class="sig-paren">(</span><span class="pre">int</span> <em><span class="pre">incoming_size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7HdrHeap18coalesce_str_heapsEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This garbage collects the string heaps in a half space style, by creating a new string space
(string heap), copying all of the strings there, and then discarding the existing string heaps.</p>
<p>The total amount of live string space is calculated by
<a class="reference internal" href="#_CPPv4N7HdrHeap29required_space_for_evacuationEv" title="HdrHeap::required_space_for_evacuation"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HdrHeap::required_space_for_evacuation()</span></code></a> and a new string heap is created of a size at
least as large as the live string space plus <em>incoming_size</em> bytes.</p>
<p>All of the live strings are moved to the new string heap by
<a class="reference internal" href="#_CPPv4N7HdrHeap23evacuate_from_str_heapsEP10HdrStrHeap" title="HdrHeap::evacuate_from_str_heaps"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HdrHeap::evacuate_from_str_heaps()</span></code></a>, the existing string heaps are deallocated, and the
new string heap becomes the writeable string heap for the header heap. The end result is a
single writeable string heap and no read only string heaps, with all live strings resident in
that writeable string heap.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N7HdrHeap12allocate_strEi">
<span id="_CPPv3N7HdrHeap12allocate_strEi"></span><span id="_CPPv2N7HdrHeap12allocate_strEi"></span><span id="HdrHeap::allocate_str__i"></span><span class="pre">char</span> <span class="pre">*</span><code class="sig-name descname"><span class="pre">allocate_str</span></code><span class="sig-paren">(</span><span class="pre">int</span> <em><span class="pre">bytes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7HdrHeap12allocate_strEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate <em>nbytes</em> of space for a string in the writeable string heap. A pointer to the
first byte is returned, or <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> if the space could not be allocated.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N7HdrHeap12allocate_objEii">
<span id="_CPPv3N7HdrHeap12allocate_objEii"></span><span id="_CPPv2N7HdrHeap12allocate_objEii"></span><span id="HdrHeap::allocate_obj__i.i"></span><a class="reference internal" href="#_CPPv414HdrHeapObjImpl" title="HdrHeapObjImpl"><span class="pre">HdrHeapObjImpl</span></a> <span class="pre">*</span><code class="sig-name descname"><span class="pre">allocate_obj</span></code><span class="sig-paren">(</span><span class="pre">int</span> <em><span class="pre">nbytes</span></em>, <span class="pre">int</span> <em><span class="pre">type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7HdrHeap12allocate_objEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a <em>type</em> object that is <em>nbytes</em> in size in the heap and return a pointer
to it, or <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> if the object could not be allocated.</p>
<p><em>nbytes</em> must be at most <code class="docutils literal notranslate"><span class="pre">HDR_MAX_ALLOC_SIZE</span></code>.</p>
<p>The members of <a class="reference internal" href="#_CPPv414HdrHeapObjImpl" title="HdrHeapObjImpl"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrHeapObjImpl</span></code></a> are initialized. Further initialization is the
responsibility of the caller.</p>
<p><em>type</em> must be one of the values specified in <a class="reference internal" href="#_CPPv414HdrHeapObjImpl" title="HdrHeapObjImpl"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrHeapObjImpl</span></code></a>.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N7HdrHeap14marshal_lengthEv">
<span id="_CPPv3N7HdrHeap14marshal_lengthEv"></span><span id="_CPPv2N7HdrHeap14marshal_lengthEv"></span><span id="HdrHeap::marshal_length"></span><span class="pre">int</span> <code class="sig-name descname"><span class="pre">marshal_length</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7HdrHeap14marshal_lengthEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute and return the size of the buffer needed to serialize <em>this</em>.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N7HdrHeap7marshalEPci">
<span id="_CPPv3N7HdrHeap7marshalEPci"></span><span id="_CPPv2N7HdrHeap7marshalEPci"></span><span id="HdrHeap::marshal__cP.i"></span><span class="pre">int</span> <code class="sig-name descname"><span class="pre">marshal</span></code><span class="sig-paren">(</span><span class="pre">char</span> <span class="pre">*</span><em><span class="pre">buffer</span></em>, <span class="pre">int</span> <em><span class="pre">length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7HdrHeap7marshalEPci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Serialize <em>this</em> to <em>buffer</em> of size <em>length</em>. It is required that
<em>length</em> be at least the value returned by <a class="reference internal" href="#_CPPv4N7HdrHeap14marshal_lengthEv" title="HdrHeap::marshal_length"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HdrHeap::marshal_length()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="cpp function">
<dt id="_CPPv411new_HdrHeapi">
<span id="_CPPv311new_HdrHeapi"></span><span id="_CPPv211new_HdrHeapi"></span><span id="new_HdrHeap__i"></span><a class="reference internal" href="#_CPPv47HdrHeap" title="HdrHeap"><span class="pre">HdrHeap</span></a> <span class="pre">*</span><code class="sig-name descname"><span class="pre">new_HdrHeap</span></code><span class="sig-paren">(</span><span class="pre">int</span> <em><span class="pre">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411new_HdrHeapi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create and return a new instance of <a class="reference internal" href="#_CPPv47HdrHeap" title="HdrHeap"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrHeap</span></code></a>. If <em>n</em> is less than <code class="docutils literal notranslate"><span class="pre">HdrHeap::DEFAULT_SIZE</span></code>
it is increased to that value.</p>
<p>If the allocated size is <code class="docutils literal notranslate"><span class="pre">HdrHeap::DEFAULT_SIZE</span></code> (or smaller and upsized to that value) then
the instance is allocated from a thread local pool via <code class="code docutils literal notranslate"><span class="pre">hdrHeapAllocator</span></code>. If larger it
is allocated from global memory via <code class="code docutils literal notranslate"><span class="pre">ats_malloc</span></code>.</p>
</dd></dl>

<div class="topic">
<p class="topic-title">Header Heap Class Structure</p>
<div class="figure align-default">
<img alt="../../_images/hdr-heap-class.svg" src="../../_images/hdr-heap-class.svg" /></div>
</div>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="string-coalescence">
<h3>String Coalescence<a class="headerlink" href="#string-coalescence" title="Permalink to this headline">¶</a></h3>
<p>String heaps do not maintain lists of internal free space. Strings that are released are left in
place, creating dead space in the heap. For this reason it can become necessary to do a garbage
collection operation on the writeable string heap in the header heap by calling
<a class="reference internal" href="#_CPPv4N7HdrHeap18coalesce_str_heapsEi" title="HdrHeap::coalesce_str_heaps"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HdrHeap::coalesce_str_heaps()</span></code></a>. This is done when</p>
<ul class="simple">
<li><p>The amount of dead space in the writable string heap exceeds <code class="docutils literal notranslate"><span class="pre">MAX_LOST_STR_SPACE</span></code>.</p></li>
<li><p>An external string heap is being added and all current read only string heap slots are used.</p></li>
</ul>
<p>The mechanism is simple in design - the size of the live string data in the current string heaps is
calculated and a new heap is allocated sufficient to contain all existing strings, with additional
space for new string data. Each heap object is required to provide a <code class="code docutils literal notranslate"><span class="pre">strings_length</span></code> method
which returns the size of the live string data for that object (recursively as needed). The strings
are copied to the new string heap, all of the previous string heaps are discarded, and the new heap
becomes the writable string heap for the header heap.</p>
<p>Each heap object is responsible for providing a <code class="code docutils literal notranslate"><span class="pre">move_strings</span></code> method which copies its strings
to a new string heap, passed as an argument. This is a source of pointer invalidation for other
parts of the core and the plugin API. For the latter, insulating from such string movement is the
point of the <a class="reference internal" href="../api/functions/TSTypes.en.html#c.TSMLoc" title="TSMLoc"><code class="xref c c-type docutils literal notranslate"><span class="pre">TSMLoc</span></code></a> type.</p>
</div>
<div class="section" id="string-allocation">
<h3>String Allocation<a class="headerlink" href="#string-allocation" title="Permalink to this headline">¶</a></h3>
<p>Storage for a string is allocated by <a class="reference internal" href="#_CPPv4N7HdrHeap12allocate_strEi" title="HdrHeap::allocate_str"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HdrHeap::allocate_str()</span></code></a>. If the current amount of dead
space is too large, this is treated as an initial allocation failure. If there is no current
writeable string heap, one is created that is a least as large as the space requested and the size
of the previous writeable string heap. Space for the string is then allocated out of the writeable
string heap. If this fails due to lack of space the current writeable string heap is “demoted” to a
read only string heap and allocation retried (which will cause a new writeable string heap). If the
writeable string heap cannot be demoted due to lack of read only slots, the strings heaps are
coalesced with an additional size request of the requested string size. This will result in a single
writeable string heap and not read only heaps, the former containing all of the existing strings plus
sufficient space to allocate the new string.</p>
<div class="topic">
<p class="topic-title">Decision Diagram</p>
<div class="figure align-default">
<img alt="../../_images/hdr-heap-str-alloc.svg" src="../../_images/hdr-heap-str-alloc.svg" /></div>
</div>
</div>
<div class="section" id="object-allocation">
<h3>Object Allocation<a class="headerlink" href="#object-allocation" title="Permalink to this headline">¶</a></h3>
<p>Objects are allocated on the header heap by <a class="reference internal" href="#_CPPv4N7HdrHeap12allocate_objEii" title="HdrHeap::allocate_obj"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HdrHeap::allocate_obj()</span></code></a>. Such objects must be one
of a compile time determined set of types <a class="footnote-reference brackets" href="#id3" id="id1">1</a>. This method first tries to allocate the object in
existing free space. If that doesn’t work then the allocator walks a list of <a class="reference internal" href="#_CPPv47HdrHeap" title="HdrHeap"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrHeap</span></code></a>
instances looking for space. If no space is found anywhere, a new <a class="reference internal" href="#_CPPv47HdrHeap" title="HdrHeap"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrHeap</span></code></a> instance is
created with twice the space of the last <a class="reference internal" href="#_CPPv47HdrHeap" title="HdrHeap"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrHeap</span></code></a> in the list and added to the list to
try.</p>
<p>Once space is found for the object, the base members of <a class="reference internal" href="#_CPPv414HdrHeapObjImpl" title="HdrHeapObjImpl"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrHeapObjImpl</span></code></a> are initialized with
the object type and size, with the <em>m_obj_flags</em> set to 0.</p>
</div>
<div class="section" id="serialization">
<h3>Serialization<a class="headerlink" href="#serialization" title="Permalink to this headline">¶</a></h3>
<p>Because heaps store the HTTP request / response data, a header heap needs to be serialized to be put
in to the cache. For performance reasons, it is desirable to be able to unserialize the serialized
data in place, rather than copying it again. That is, the data is read from disk into a block of
memory and then that memory is converted to a live data structure. In this case the memory used by
the heap is owned by some other object and the header heap must not do any clean up. This is
signaled by the <cite>m_writeable</cite> flag. In an unserialized header heap this is set to <code class="docutils literal notranslate"><span class="pre">false</span></code> and such
a header heap is not allowed to allocate any additional objects or strings - it is immutable.</p>
<p>The primary mechanism to do this is to use swizzling on the pointers in the structure. During
serialization pointers are converted to offsets and during unserialization these offsets are
converted back to pointers. To make this simpler, unserialized header heaps are marked read only so
that updating does not have to be supported. Additionally, <a class="reference internal" href="#_CPPv47HdrHeap" title="HdrHeap"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">HdrHeap</span></code></a> is a POD and therefore
has no virtual function table pointer to be stored or restored <a class="footnote-reference brackets" href="#id4" id="id2">2</a>.</p>
<p>To serialize, first <a class="reference internal" href="#_CPPv4N7HdrHeap14marshal_lengthEv" title="HdrHeap::marshal_length"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HdrHeap::marshal_length()</span></code></a> is called to get a buffer size. The
serialization buffer is created with sufficient space for the header heap and that space is passed
to <a class="reference internal" href="#_CPPv4N7HdrHeap7marshalEPci" title="HdrHeap::marshal"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HdrHeap::marshal()</span></code></a> to perform the actual serialization. The object heaps are serialized
followed by the string heaps. No coalescence is done, on the presumption that because the amount
of dead space is limited by coalescence (as needed) on every string creation.</p>
<p>When serializing strings, each object is responsible for swizzling its own pointers. Because the
object heaps have already been serialized and all of the header heap object types are also PODs,
these serialized objects can have the pointer swizzling method, <code class="code docutils literal notranslate"><span class="pre">marshal</span></code>, called directly
on them. This method is provided with a set of “translations” which indicate the base offset for
each range of object and string heap memory. The object marshalling can then compute the correct
offset to store for each live string pointer.</p>
</div>
<div class="section" id="inheriting-strings">
<h3>Inheriting Strings<a class="headerlink" href="#inheriting-strings" title="Permalink to this headline">¶</a></h3>
<p>The string heaps are designed to be reference counted so that they can be shared as read only
objects between heaps. This enables copying heap objects between heaps less expensive as the
strings pointers in them can be preserved in the new heap by sharing the string heaps in which
those strings reside.</p>
<p>This can still be a bit complex as it is possible that the combined number of string heaps is more
than the limit. In this case, the target header heap does string coalescence so that it is reduced to
having a single writeable string heap with enough free space to hold all of the strings in the
source header heap. As a result, it is required that all heap objects already be present in the
target header heap before the strings are inherited. This means that the string coalescence will
properly copy the strings of and update the strings pointers in the copied heap objects.</p>
<p class="rubric">Footnotes.</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Not that I can see any good reason for that, if virtual methods instead of <code class="code docutils literal notranslate"><span class="pre">switch</span></code>
statements were used.</p>
</dd>
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Which makes the initialization logic to “fixup” the virtual function pointer rather silly.</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="rpc.en.html" class="btn btn-neutral float-right" title="RPC" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index.en.html" class="btn btn-neutral float-left" title="Core Architecture" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, dev@trafficserver.apache.org.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Apache Traffic Server</span>
    v: 10.0
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl id="lang-list">
      <dt>Languages</dt>
    </dl>
    <dl id="version-list">
      <dt>Versions</dt>
    </dl>
  </div>
</div>
<script>
$(function() {
  function update_langlist (json) {
    for (var lang in json) {
      $('#lang-list').append('<dd><a href="/' + lang + '/latest/">' + json[lang]['name'] + '</a></dd>');
    }
    for (var i in json[curlang]['versions']) {
      var ver = json[curlang]['versions'][i];
      $('#version-list').append('<dd><a href="/' + curlang + '/' + ver + '/">' + ver + '</a></dd>');
    }
  }
  var curlang = "None" == "None" ? "en" : "None";
  $.ajax({
    'url':      "/en/latest/_static/languages.json",
    'dataType': "json",
    'success':  function (json) { update_langlist(json) },
    'error':    function (xhr,errstr,e) {
      $.ajax({
        'url':      "/_static/languages.json",
        'dataType': "json",
        'success':  function (json) { update_langlist(json) }
      })
    }
  });
});
</script>
 


</body>
</html>